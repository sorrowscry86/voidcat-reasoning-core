{
  "id": "fba7668c-9490-4b2d-9064-82d4ef0602d7",
  "title": "FastMCP Implementation",
  "details": "\"\"\"\nFastMCP - Modern Model Control Protocol Implementation\nA streamlined, async-first implementation of the Model Control Protocol\nusing FastAPI and modern Python patterns.\n\"\"\"\n\nimport asyncio\nimport inspect\nimport json\nimport logging\nimport sys\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Callable, Dict, List, Optional, Type, Union, get_type_hints\n\nfrom fastapi import FastAPI, HTTPException, Request, Response, status\nfrom fastapi.responses import JSONResponse\nfrom pydantic import BaseModel, Field, create_model\n\n# Try to import the VoidCat engine components\ntry:\n    from enhanced_engine import VoidCatEnhancedEngine\n    from voidcat_context_integration import VoidCatContextIntegration\n    from voidcat_memory_integration import VoidCatMemoryIntegration\n    HAS_VOIDCAT = True\nexcept ImportError:\n    HAS_VOIDCAT = False\n    logging.warning(\"VoidCat components not available. Some features will be disabled.\")\n\n# Configure logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\"%(asctime)s - %(name)s - %(levelname)s - %(message)s\",\n)\nlogger = logging.getLogger(\"fastmcp\")\n\n\nclass ToolCategory(str, Enum):\n    \"\"\"Categories for organizing tools.\"\"\"\n    REASONING = \"reasoning\"\n    MEMORY = \"memory\"\n    CONTEXT = \"context\"\n    UTILITY = \"utility\"\n    SYSTEM = \"system\"\n\n\n@dataclass\nclass ToolDefinition:\n    \"\"\"Modern tool definition with enhanced metadata.\"\"\"\n    name: str\n    description: str\n    function: Callable\n    category: ToolCategory = ToolCategory.UTILITY\n    parameters: Dict[str, Any] = field(default_factory=dict)\n    schema: Optional[Dict[str, Any]] = None\n    \n    def __post_init__(self):\n        \"\"\"Generate schema from function signature if not provided.\"\"\"\n        if self.schema is None:\n            self.schema = self._generate_schema_from_function()\n    \n    def _generate_schema_from_function(self) -> Dict[str, Any]:\n        \"\"\"Generate a JSON schema from the function signature.\"\"\"\n        sig = inspect.signature(self.function)\n        type_hints = get_type_hints(self.function)\n        \n        properties = {}\n        required = []\n        \n        for name, param in sig.parameters.items():\n            # Skip self, cls, and context parameters\n            if name in ('self', 'cls', 'ctx', 'context'):\n                continue\n                \n            param_type = type_hints.get(name, Any)\n            param_schema = {\"type\": \"string\"}  # Default\n            \n            # Handle different types\n            if param_type == int:\n                param_schema = {\"type\": \"integer\"}\n            elif param_type == float:\n                param_schema = {\"type\": \"number\"}\n            elif param_type == bool:\n                param_schema = {\"type\": \"boolean\"}\n            elif param_type == List[str]:\n                param_schema = {\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n            elif param_type == Dict[str, Any]:\n                param_schema = {\"type\": \"object\"}\n            \n            # Check for default value\n            if param.default != inspect.Parameter.empty:\n                param_schema[\"default\"] = param.default\n            else:\n                required.append(name)\n            \n            # Add description from parameters dict if available\n            if name in self.parameters:\n                param_schema.update(self.parameters[name])\n            \n            properties[name] = param_schema\n        \n        return {\n            \"type\": \"object\",\n            \"properties\": properties,\n            \"required\": required\n        }\n\n\nclass ExecutionContext:\n    \"\"\"Context for tool execution with request information and utilities.\"\"\"\n    \n    def __init__(self, request_id: str = None):\n        self.request_id = request_id or f\"req_{id(self)}\"\n        self.start_time = asyncio.get_event_loop().time()\n        self.logs = []\n    \n    def log(self, message: str, level: str = \"INFO\"):\n        \"\"\"Log a message with the current context.\"\"\"\n        self.logs.append({\"level\": level, \"message\": message, \"time\": asyncio.get_event_loop().time() - self.start_time})\n        if level == \"ERROR\":\n            logger.error(f\"[{self.request_id}] {message}\")\n        elif level == \"WARNING\":\n            logger.warning(f\"[{self.request_id}] {message}\")\n        else:\n            logger.info(f\"[{self.request_id}] {message}\")\n    \n    async def notify(self, message: str, notification_type: str = \"info\"):\n        \"\"\"Send a notification to the client.\"\"\"\n        # This would be implemented with WebSockets in a full implementation\n        self.log(f\"NOTIFICATION ({notification_type}): {message}\")\n\n\nclass FastMCP:\n    \"\"\"\n    Modern, FastAPI-based implementation of the Model Control Protocol.\n    Provides a clean, async-first API for tool registration and execution.\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize the FastMCP server.\"\"\"\n        self.tools: Dict[str, ToolDefinition] = {}\n        self.app = FastAPI(title=\"FastMCP\", description=\"Modern Model Control Protocol\")\n        \n        # Initialize VoidCat components if available\n        self.engine = None\n        self.context_integration = None\n        self.memory_integration = None\n        \n        if HAS_VOIDCAT:\n            self.engine = VoidCatEnhancedEngine()\n            self.context_integration = VoidCatContextIntegration()\n            self.memory_integration = VoidCatMemoryIntegration()\n        \n        # Register built-in routes\n        self._register_routes()\n    \n    def _register_routes(self):\n        \"\"\"Register the FastAPI routes.\"\"\"\n        \n        @self.app.get(\"/health\")\n        async def health_check():\n            \"\"\"Health check endpoint.\"\"\"\n            return {\"status\": \"healthy\", \"tools_count\": len(self.tools)}\n        \n        @self.app.post(\"/execute/{tool_name}\")\n        async def execute_tool(tool_name: str, request: Request):\n            \"\"\"Execute a tool by name with the provided parameters.\"\"\"\n            if tool_name not in self.tools:\n                raise HTTPException(\n                    status_code=status.HTTP_404_NOT_FOUND,\n                    detail=f\"Tool '{tool_name}' not found\"\n                )\n            \n            # Parse the request body\n            try:\n                body = await request.json()\n            except json.JSONDecodeError:\n                body = {}\n            \n            # Create execution context\n            ctx = ExecutionContext(request_id=request.headers.get(\"X-Request-ID\"))\n            \n            # Execute the tool\n            try:\n                result = await self._execute_tool(tool_name, ctx, **body)\n                return {\n                    \"status\": \"success\",\n                    \"tool\": tool_name,\n                    \"result\": result,\n                    \"logs\": ctx.logs\n                }\n            except Exception as e:\n                ctx.log(f\"Error executing tool {tool_name}: {str(e)}\", \"ERROR\")\n                raise HTTPException(\n                    status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n                    detail=f\"Error executing tool: {str(e)}\"\n                )\n        \n        @self.app.get(\"/tools\")\n        async def list_tools():\n            \"\"\"List all registered tools with their schemas.\"\"\"\n            return {\n                \"tools\": [\n                    {\n                        \"name\": name,\n                        \"description\": tool.description,\n                        \"category\": tool.category,\n                        \"schema\": tool.schema\n                    }\n                    for name, tool in self.tools.items()\n                ]\n            }\n    \n    def register_tool(self, \n                     func: Callable = None, \n                     *, \n                     name: str = None, \n                     description: str = None,\n                     category: ToolCategory = ToolCategory.UTILITY,\n                     parameters: Dict[str, Any] = None,\n                     schema: Dict[str, Any] = None):\n        \"\"\"\n        Register a function as a tool.\n        Can be used as a decorator or called directly.\n        \"\"\"\n        def decorator(func):\n            nonlocal name, description, parameters\n            \n            # Use function name if not provided\n            if name is None:\n                name = func.__name__\n            \n            # Use function docstring if description not provided\n            if description is None:\n                description = func.__doc__ or f\"Tool: {name}\"\n            \n            # Create parameters dict if not provided\n            if parameters is None:\n                parameters = {}\n            \n            # Register the tool\n            self.tools[name] = ToolDefinition(\n                name=name,\n                description=description,\n                function=func,\n                category=category,\n                parameters=parameters,\n                schema=schema\n            )\n            \n            return func\n        \n        # Handle both @register_tool and register_tool(func)\n        if func is not None:\n            return decorator(func)\n        return decorator\n    \n    async def _execute_tool(self, tool_name: str, ctx: ExecutionContext, **kwargs):\n        \"\"\"Execute a tool with the given parameters.\"\"\"\n        tool = self.tools.get(tool_name)\n        if not tool:\n            raise ValueError(f\"Tool '{tool_name}' not found\")\n        \n        # Log tool execution\n        ctx.log(f\"Executing tool: {tool_name}\")\n        \n        # Get the function\n        func = tool.function\n        \n        # Check if the function is async\n        is_async = inspect.iscoroutinefunction(func)\n        \n        # Add context to kwargs if the function accepts it\n        sig = inspect.signature(func)\n        if 'ctx' in sig.parameters or 'context' in sig.parameters:\n            param_name = 'ctx' if 'ctx' in sig.parameters else 'context'\n            kwargs[param_name] = ctx\n        \n        # Execute the function\n        try:\n            if is_async:\n                result = await func(**kwargs)\n            else:\n                # Run synchronous functions in a thread pool\n                loop = asyncio.get_event_loop()\n                result = await loop.run_in_executor(\n                    None, lambda: func(**kwargs)\n                )\n            \n            ctx.log(f\"Tool {tool_name} executed successfully\")\n            return result\n        except Exception as e:\n            ctx.log(f\"Error in tool {tool_name}: {str(e)}\", \"ERROR\")\n            raise\n\n\n# Add built-in tools and helper functions\n\nasync def send_debug_notification(ctx: ExecutionContext, message: str) -> None:\n    \"\"\"Send a debug notification to the client.\"\"\"\n    await ctx.notify(message, \"debug\")\n    return {\"status\": \"sent\", \"message\": message}\n\n\nasync def send_log_notification(\n    ctx: ExecutionContext, \n    message: str, \n    level: str = \"info\"\n) -> None:\n    \"\"\"Send a log notification to the client.\"\"\"\n    await ctx.notify(message, level)\n    return {\"status\": \"sent\", \"message\": message, \"level\": level}\n\n\ndef create_fastmcp_instance():\n    \"\"\"Create and configure a FastMCP instance with standard tools.\"\"\"\n    mcp = FastMCP()\n    \n    # Register built-in tools\n    @mcp.register_tool(\n        name=\"debug_notification\",\n        description=\"Send a debug notification to the client\",\n        category=ToolCategory.SYSTEM,\n        parameters={\n            \"message\": {\n                \"description\": \"The message to send\",\n                \"type\": \"string\"\n            }\n        }\n    )\n    async def debug_notification(ctx: ExecutionContext, message: str):\n        return await send_debug_notification(ctx, message)\n    \n    @mcp.register_tool(\n        name=\"log_notification\",\n        description=\"Send a log notification to the client\",\n        category=ToolCategory.SYSTEM,\n        parameters={\n            \"message\": {\n                \"description\": \"The message to send\",\n                \"type\": \"string\"\n            },\n            \"level\": {\n                \"description\": \"Log level\",\n                \"type\": \"string\",\n                \"default\": \"info\",\n                \"enum\": [\"info\", \"warning\", \"error\", \"debug\"]\n            }\n        }\n    )\n    async def log_notification(ctx: ExecutionContext, message: str, level: str = \"info\"):\n        return await send_log_notification(ctx, message, level)\n    \n    # Register reasoning tools if VoidCat is available\n    if HAS_VOIDCAT:\n        @mcp.register_tool(\n            name=\"enhanced_reasoning\",\n            description=\"Perform enhanced reasoning with the VoidCat engine\",\n            category=ToolCategory.REASONING,\n            parameters={\n                \"query\": {\n                    \"description\": \"The query to reason about\",\n                    \"type\": \"string\"\n                },\n                \"model\": {\n                    \"description\": \"AI model to use for reasoning\",\n                    \"type\": \"string\",\n                    \"default\": \"gpt-4o-mini\",\n                    \"enum\": [\"gpt-4o-mini\", \"gpt-4o\", \"gpt-3.5-turbo\"]\n                },\n                \"max_sources\": {\n                    \"description\": \"Number of relevant documents to retrieve for context\",\n                    \"type\": \"integer\",\n                    \"default\": 3,\n                    \"minimum\": 1,\n                    \"maximum\": 5\n                },\n                \"include_diagnostics\": {\n                    \"description\": \"Include detailed diagnostic information\",\n                    \"type\": \"boolean\",\n                    \"default\": False\n                }\n            }\n        )\n        async def enhanced_reasoning(\n            ctx: ExecutionContext, \n            query: str, \n            model: str = \"gpt-4o-mini\",\n            max_sources: int = 3,\n            include_diagnostics: bool = False\n        ):\n            \"\"\"Perform enhanced reasoning with the VoidCat engine.\"\"\"\n            ctx.log(f\"Processing query with {model}, max_sources={max_sources}\")\n            \n            try:\n                result = await mcp.engine.process_query(\n                    query=query,\n                    model=model,\n                    max_sources=max_sources\n                )\n                \n                response = {\n                    \"answer\": result.answer,\n                    \"sources_used\": len(result.sources) if result.sources else 0\n                }\n                \n                if include_diagnostics:\n                    response[\"diagnostics\"] = {\n                        \"processing_time\": result.processing_time,\n                        \"token_usage\": result.token_usage,\n                        \"sources\": [s.title for s in result.sources] if result.sources else []\n                    }\n                \n                return response\n            except Exception as e:\n                ctx.log(f\"Error in enhanced reasoning: {str(e)}\", \"ERROR\")\n                raise\n    \n    return mcp\n\n\ndef run_fastmcp_server(host: str = \"0.0.0.0\", port: int = 8000):\n    \"\"\"Run the FastMCP server.\"\"\"\n    import uvicorn\n    \n    mcp = create_fastmcp_instance()\n    logger.info(f\"Starting FastMCP server with {len(mcp.tools)} tools\")\n    \n    uvicorn.run(mcp.app, host=host, port=port)\n\n\nif __name__ == \"__main__\":\n    run_fastmcp_server()",
  "category": "code",
  "dateCreated": "2025-07-27T10:38:10.959Z",
  "dateUpdated": "2025-07-27T10:38:10.959Z"
}